#!/bin/bash

# Eternal bash history.
# ---------------------
# Undocumented feature which sets the size to "unlimited".
# http://stackoverflow.com/questions/9457233/unlimited-bash-history
export HISTFILESIZE=
export HISTSIZE=
export HISTTIMEFORMAT="[%F %T] "
# Change the file location because certain bash sessions truncate .bash_history file upon close.
# http://superuser.com/questions/575479/bash-history-truncated-to-500-lines-on-each-login
export HISTFILE=~/.bash_eternal_history

export EDITOR=nvim

# Use vi-editing modde. Also note .inputrc has 'set editing-mode: vi'.
#set -o vi

# File containing bash aliases. Reloaded before each prompt.
ALIASES_FILE="${HOME}/.bash_aliases"

_last_exit_status=0
_last_alias_status=0
PROMPT_COMMAND='_last_exit_status=$?; history -a; setup_git_vars; source_aliases; '
PS1=
PS1+=$'\n'
PS1+='$(print_aliases_status)'
PS1+='$(print_exit_status ${_last_exit_status})'
PS1+='$(print_time)'
PS1+='$(print_git_branch)'
PS1+='$(print_virtualenv)'
PS1+=$'\n'
PS1+='\[\033[01;32m\]\u@\h\[\033[01;34m\] \w'
PS1+=$'\n'
PS1+='\$\[\033[00m\] '

print_aliases_status() {
    if [ "${_last_alias_status}" -ne 0 ]; then
        # (extra \r is so that bash doesn't eat the trailing newline)
        printf '%sWarning:%s Failed to load aliases (status: %s).\n\r' \
            "$(tput setaf 1)" "$(tput sgr0)" "${_last_alias_status}"
    fi
}
print_exit_status() {
    if [[ "$1" -ne 0 ]]; then
        tput bold
        tput setaf 1
        printf '[✕ %3d]' "$1"
    else
        tput setaf 4
        printf '[✓]'
    fi
    tput sgr0
}
setup_git_vars() {
    if BRANCH="$(git rev-parse --abbrev-ref HEAD 2>&1)"; then
        GIT=1
        FULL_SHA="$(git rev-parse HEAD)"
        SHA="$(<<< "${FULL_SHA}" head -c 10)"
        if ! git symbolic-ref HEAD 1>/dev/null 2>&1; then
            DETACHED=1
        else
            DETACHED=0
        fi
    else
        GIT=0
        FULL_SHA=
        SHA=
        DETACHED=
    fi
}
print_time() {
    printf ' %s%s%s' \
        "$(tput setaf 6)" "$(date +'%H:%M:%S(%s)')" "$(tput sgr0)"
}
print_git_branch() {
    if [[ "${GIT}" -eq 1 ]]; then
        tput setaf 4
        if [[ "${DETACHED}" -eq 1 ]]; then
            printf ' [%s]' "${SHA}"
        else
            printf ' [%s|%s]' "${BRANCH}" "${SHA}"
        fi
        tput sgr0
    fi
}
print_virtualenv() {
    if [ -n "${VIRTUAL_ENV}" ]; then
        tput setaf 6
        printf ' %s(%s)%s' \
            "$(tput setaf 6)" \
            "$(basename "${VIRTUAL_ENV}")" \
            "$(tput sgr0)" \
            ;
    fi
}
source_aliases() {
    _last_alias_status=0
    ( source "${ALIASES_FILE}" ) || _last_alias_status=$?
    if [ "${_last_alias_status}" -eq 0 ]; then
        source "${ALIASES_FILE}"
    fi
}

export VIRTUAL_ENV_DISABLE_PROMPT=1

# default: find * -path '*/\.*' -prune -o -type f -print -o -type l -print 2> /dev/null
# we want to ignore node_modules as well
export FZF_DEFAULT_COMMAND='{ git ls-tree -r --name-only HEAD || find * \( -path '\''*/\.*'\'' -o -path '\''node_modules/*'\'' \) -prune -o -type f -print -o -type l -print 2> /dev/null; }'
export FZF_CTRL_T_COMMAND="${FZF_DEFAULT_COMMAND}"

export CLICOLOR=yesplz

# Use a terminal with support for italic colors. If this creates
# problems, run set_up_italics.
export TERM=xterm-256color-italic
set_up_italics() {
    # https://gist.githubusercontent.com/sos4nt/3187620/raw/8e13c1fec5b72d415ed2917590348451de5f8e58/xterm-256color-italic.terminfo
    tic - << EOF
xterm-256color-italic|xterm with 256 colors and italic,
    sitm=\E[3m, ritm=\E[23m,
    use=xterm-256color,
EOF
}

[ -f ~/.fzf.bash ] && source ~/.fzf.bash
